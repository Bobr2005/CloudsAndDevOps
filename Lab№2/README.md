# Лабораторная №2

## Условие
## Обычное:
1. Написать “плохой” Dockerfile, в котором есть не менее трех “bad practices” по написанию докерфайлов
2. Написать “хороший” Dockerfile, в котором эти плохие практики исправлены
3. В Readme описать каждую из плохих практик в плохом докерфайле, почему она плохая и как в хорошем она была исправлена, как исправление повлияло на результат
4. В Readme описать 2 плохих практики по работе с контейнерами. ! Не по написанию докерфайлов, а о том, как даже используя хороший докерфайл можно накосячить именно в работе с контейнерами.

## Решение:
На самом деле написать что-то "плохое" и главное рабочее, нужно очень постараться, ведь один неверный шаг и ваш проект не будет работать. Dockerfile не стал исключением, однако сделать его несломанным получилось.
Для приготовления "плохого" Dockerfile'а нам понадобится:
1. Создать директорию и зайти в неё, где мы и будем работать. Для этого нам потребуется:
```
   mkdir bad-docker-file

   cd bad-docker-file
```
2. Далее создаём файл requirements.txt, добавляем в него
```
   Flask==2.1.2

   Werkzeug==2.1.2
```
, потому что мы сделаем простенькое веб-приложение на Python

3. Создаём папку src в папке bad-docker-file, в ней создаём main.py, в файл вставляем следующий код:
  ```
      from flask import Flask
  
      app = Flask(__name__)
  
      @app.route('/')
   
      def hello():
      
        return "Hello, World!"
  
      app.run(host='0.0.0.0')
```

4. Теперь самое интересное, ведь от следующего шага зависит будущее нашего блюда, так как если в него добавить что-то лишнее или наоборот пожадничать ингридиентами, то мы останемся недовольными своим трудом. Вот рецепт Dockerfile'a, только тсс-ссс:
  ```FROM ubuntu:latest

  RUN apt-get update
  RUN apt-get install -y python3 python3-pip nano wget curl

  WORKDIR /app

  COPY src/ /app/
  COPY requirements.txt /app/

  RUN pip3 install --break-system-packages -r requirements.txt

  ENV PYTHON_VERSION=3.8

  CMD ["python3", "main.py"]
```
Пробежимся кратко по нашему рецепту: 

  А) Указываем образ, в нашем случае это крайний доступный образ Ubuntu;
  
  B) Обновляем информацию о доступных пакетах и их версиях
  
  С) Устанавливаем интерпретатор Python 3, инструмент для установки пакетов Python, текстовый редактор для редактирования файлов в контейнере, утилиты для скачивания файлов и выполнения HTTP-запросов;
  
  D) Задаём рабочую директорию;
  
  E) Копируем наши файлы;
  
  F) Устанавливаем Python-пакеты с дополнительным параметром **--break-system-packages**, чтобы уж точно всё завелось;
  
  G) Устанавливаем переменную окружения
  
  I) Указываем команду
  
5. После приготовления блюдо должно подышать, для этого нужно создать образ командой 
```
  docker build -t bad-python-app .
```
, ждать придётся недолго, в нашем случае было достаточно 184 секунд

![image](https://github.com/user-attachments/assets/f976eec0-bee8-41c6-a58a-f84fafca1a08)

6. Вот и всё, осталось только взять столовые приборы и наслаждаться. Приятного аппетита!
   
![image](https://github.com/user-attachments/assets/064668d6-ec8a-49be-bf2b-1324e3ed7e9c)







## Конечно же вам не понравится данный шедевр кулинарии, ведь сразу же заметите, что в вашу же тарелку навалили какой-то базы, от которой станет очень дурно...

# Let's fix it!

1. Самое главное исправить Dockerfile:

  ```FROM python:3.8-slim

  RUN apt-get update && \
      apt-get install -y --no-install-recommends \
      nano \
      wget \
      curl && \
      rm -rf /var/lib/apt/lists/*

  WORKDIR /app

  COPY src/ /app/
  COPY requirements.txt /app/

  RUN pip install --no-cache-dir -r requirements.txt

  ENV PYTHON_VERSION=3.8

  CMD ["python", "main.py"]
```
Отличия от предыдущей версии на лицо: мы поменяли образ на Python, устанавливаем только то, что нам нужно, при чём без кэшированных пакетов. Также добавили  **requests==2.28.1**
в requirements.txt. Не забываем про наши столовые приборы:
```
  docker run --rm -p 5000:5000 good-python-app
  ```
только в этот раз будем есть ложкой, а не лопатой.

## Но почему же первая версия Dockerfile'a получилась плохой?

1. Мы использовали образ Ubuntu, это ну ООООчень избыточно для нашей цели со всеми вытекающими
2. Во второй версии у нас одна команда Run, что снизило кол-во слоёв
3. Использование флага **--break-system-packages** может привести к конфликтам, что может пойти не так, наверно, сами знаете)

А ещё давайте вспомним про ошибку в 1 случае: мы не прописали флаг --rm, ведь зачем нам сейчас этот контейнер после нашей трапезы?

## Вместо компота давайте лучше расскажу про 2 плохие практики по работе с контейнерами.

1. Не забывайте останавливать работу контейнеров, если они вам более не потребуются, экономьте ресурсы
2. Не используйте избыточные привилегии, иначе последствия получения данных не в те руки могут быть непоправимыми

# That's all!
