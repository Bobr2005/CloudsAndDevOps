# Лабораторная №2

## Условие
## Обычное:
1. Написать “плохой” Dockerfile, в котором есть не менее трех “bad practices” по написанию докерфайлов
2. Написать “хороший” Dockerfile, в котором эти плохие практики исправлены
3. В Readme описать каждую из плохих практик в плохом докерфайле, почему она плохая и как в хорошем она была исправлена, как исправление повлияло на результат
4. В Readme описать 2 плохих практики по работе с контейнерами. ! Не по написанию докерфайлов, а о том, как даже используя хороший докерфайл можно накосячить именно в работе с контейнерами.

## Решение:
На самом деле написать что-то "плохое" и главное рабочее, нужно очень постараться, ведь один неверный шаг и ваш проект не будет работать. Dockerfile не стал исключением, однако сделать его несломанным получилось.
Для приготовления "плохого" Dockerfile'а нам понадобится:
1. Создать директорию и зайти в неё, где мы и будем работать. Для этого на потребуется:

   **mkdir bad-docker-file**

   **cd bad-docker-file**
3. Далее создаём файл requirements.txt, добавляем в него
   Flask==2.1.2
   Werkzeug==2.1.2
, потому что мы сделаем простенькое веб-приложение на Python
![image](https://github.com/user-attachments/assets/e0076ef5-54f1-4126-bcbb-9ac6934cbb45)
4. Создаём папку src в папке bad-docker-file, в ней создаём main.py, в файл вставляем следующий код:
   from flask import Flask

  app = Flask(__name__)

  @app.route('/')
  def hello():
    return "Hello, World!"

  app.run(host='0.0.0.0')

5. Теперь самое интересное, ведь от следующего шага зависит будущее нашего блюда, ведь если в него добавить что-то лишнее или наоборот пожадничать ингридиентами, то мы останемся недовольными своим трудом. Вот рецепт Dockerfile'a, только тсс-ссс:
  FROM ubuntu:latest

  RUN apt-get update
  RUN apt-get install -y python3 python3-pip nano wget curl

  WORKDIR /app

  COPY src/ /app/
  COPY requirements.txt /app/

  RUN pip3 install --break-system-packages -r requirements.txt

  ENV PYTHON_VERSION=3.8

  CMD ["python3", "main.py"]

Пробежимся кратко по нашему рецепту: 
  А) Указываем образ, в нашем случае это крайний доступный образ Ubuntu;
  B) Обновляем информацию о доступных пакетах и их версиях
  С) Устанавливаем интерпретатор Python 3, инструмент для установки пакетов Python, текстовый редактор для редактирования файлов в контейнере, утилиты для скачивания файлов и выполнения HTTP-запросов;
  D) Задаём рабочую директорию;
  E) Копируем наши файлы;
  F) Устанавливает Python-пакеты с дополнительным параметром --break-system-packages, чтобы уж точно всё завелось;
  G) Устанавливаем переменную окружения
  I) Указываем команду
6. После приготовления, блюдо должно подышать, для этого нужно создать образ командой 
  docker build -t bad-python-app .
, ждать придётся недолго, мне было достаточно 184 секунд
![image](https://github.com/user-attachments/assets/f976eec0-bee8-41c6-a58a-f84fafca1a08)
7. Вот и всё, осталось только взять столовые приборы и наслаждаться. Приятного аппетита!
![image](https://github.com/user-attachments/assets/064668d6-ec8a-49be-bf2b-1324e3ed7e9c)

## Конечно же вам не понравится данный шедевр кулинарии, ведь сразу же заметите, что в вашу же тарелку навалили какой-то базы, от которой станет очень дурно...

# Let's fix it!

1. Самое главное исправить Dockerfile:
   FROM python:3.8-slim

  RUN apt-get update && \
      apt-get install -y --no-install-recommends \
      nano \
      wget \
      curl && \
      rm -rf /var/lib/apt/lists/*

  WORKDIR /app

  COPY src/ /app/
  COPY requirements.txt /app/

  RUN pip install --no-cache-dir -r requirements.txt

  ENV PYTHON_VERSION=3.8

  CMD ["python", "main.py"]

Отличия от предыдущей версии на лицо: мы поменяли образ на Python, устанавливаем только то, что нам нужно, при чём без кэшированных пакетов. Я также добавил 
  requests==2.28.1
в requirements.txt. Не забываем про наши столовые приборы:
  docker run --rm -p 5000:5000 good-python-app
только в этот раз будем есть ложкой, а не лопатой.

## Но почему же первая версия Dockerfile'a получилась плохой?

1. Мы использовали образ Ubuntu, это ну ООООчень избыточно для нашей цели со всеми вытекающими
2. Во второй версии у нас одна команда Run, что снизило кол-во слоёв
3. Использование флага --break-system-packages может привести к конфликтам, что может пойти не так, думаю, сами знаете)

А ещё давайте вспомним про грубейшую ошибку в 1 случае: мы не прописали флаг --rm, ведь зачем нам сейчас этот контейнер после нашей трапезы?

## Вместо компота давайте лучше расскажу про 2 плохие практики по работе с контейнерами.

1. Не забывайте останавливать работу контейнеров, если они вам более не потребуются, экономьте ресурсы
2. Не используйте избыточные привилегии, иначе последствия получения данных не в те руки могут быть непоправимыми

# That's all!
